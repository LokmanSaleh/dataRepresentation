package com.automl.datarepresentation.service;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.stream.Collectors;

import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JScrollPane;
import javax.swing.JTable;

import org.apache.commons.collections15.map.HashedMap;
import org.drools.core.audit.WorkingMemoryInMemoryLogger;
import org.drools.core.audit.event.LogEvent;
import org.drools.core.audit.event.RuleFlowNodeLogEvent;
import org.jbpm.test.JBPMHelper;
import org.kie.api.KieBase;
import org.kie.api.KieServices;
import org.kie.api.runtime.KieContainer;
import org.kie.api.runtime.KieSession;
import org.kie.api.runtime.manager.RuntimeEngine;
import org.kie.api.runtime.manager.RuntimeEnvironmentBuilder;
import org.kie.api.runtime.manager.RuntimeManager;
import org.kie.api.runtime.manager.RuntimeManagerFactory;
import org.kie.internal.runtime.StatefulKnowledgeSession;

import com.automl.datarepresentation.bd.SQLrequest;
import com.automl.datarepresentation.bean.Column;
import com.automl.datarepresentation.bean.ComboItem;
import com.automl.datarepresentation.bean.DataBase;
import com.automl.datarepresentation.bean.StaticPaths;
import com.automl.datarepresentation.bean.Table;
import com.automl.datarepresentation.bean.TableOfAutoGeneratedRequest;
import com.automl.datarepresentation.view.PrintPythonResult;
import com.automl.datarepresentation.view.SelectCreatExecute;
import com.opencsv.CSVWriter;

import weka.core.Attribute;
import weka.core.DenseInstance;
import weka.core.Instance;
import weka.core.Instances;

public class DataSchemaService {
	
	private SQLrequest sqLrequest;
 
	public DataSchemaService(SQLrequest sqLrequest) {
		super();
		this.sqLrequest = sqLrequest;
	}

	/**
	 * Get the schema 
	 * @param rs The result set 
	 * @return the set of tables 
	 * @throws SQLException
	 */
	public TreeMap<String, Table> getTables () throws SQLException {
		
		// get the data base schema
		ResultSet rs = sqLrequest.getRelationalDbStucture();
		
		TreeMap<String, Table> tables = new TreeMap<String, Table>();
		
		while (rs.next()) {

			if (tables.get(rs.getString("tableName")) == null) {

				Table table = new Table(rs.getString("tableName"));
				table.setNumber(tables.size());
				
				tables.put(rs.getString("tableName"), table);

				tables.get(rs.getString("tableName")).getColumns().put(rs.getString("columnName"),
						new Column(rs.getString("tablename"), rs.getString("columnName"), rs.getBoolean("isforeignkey"),
								rs.getString("parentTable"), rs.getString("parentColumn")));

			} else {
				tables.get(rs.getString("tableName")).getColumns().put(rs.getString("columnName"),
						new Column(rs.getString("tablename"), rs.getString("columnName"), rs.getBoolean("isforeignkey"),
								rs.getString("parentTable"), rs.getString("parentColumn")));
			}

		}
		
		
		return tables;

	}
	
	/**
	 * Veuillez noter que l'auto generation de requet SQL ici est exhaustive,
	 * cela, doit retourner une solution correct mais pas du facon performante.
	 * une solution performante non exhaustive, besoin de travailler sur les algorithms de graphe
	 * ce qui a besoin un peu plus du temps. Vue que notre probleme essentiel n'est pas cette point ici
	 * cette solution est semi-automatique. 
	 *
	 * @param tables
	 * @return the auto generated requested based on the user selection
	 */
	public String getAutoGeneratedSQLRequest(TreeMap<String, Table> tables) {
		
		String request = "";
		String select = "SELECT ";
		String from =" From ";
		String where=" Where ";
		
		for (Map.Entry<String, Table> table : tables.entrySet() ) {
			
			table.getValue().generateSelectFromWhere(tables);
			
			select += table.getValue().getSelect();
			from += table.getValue().getFrom();
			
			where += table.getValue().getWhere();
		}
		
		// remove the last comma
		if (select.length() > "SELECT ".length() ) 
			select = select.substring(0, select.length() -2);
		else 
			select ="";
		
		// remove the last comma
		if (from.length() > " From ".length() ) 
			from = from.substring(0, from.length() -2);
		else 
			from="";

		// remove the last AND from where
		if (where.length() > " Where ".length() ) 
			where = where.substring(0, where.length() -5);
		else 
			where = "";
		
		if (select.length() > 0)
			request = select + "\n"+ from + "\n" + where;
		else 
			request = "";
		
		return request;
	}

	/**
	 * 
	 * @param request the auto generated request
	 * @return the data selected
	 * @throws SQLException
	 */
	public TableOfAutoGeneratedRequest getValuesOfAutoGeneratedRequest(String request) throws SQLException {
		
		TableOfAutoGeneratedRequest tableOfAutoGeneratedRequest = new TableOfAutoGeneratedRequest();

		ResultSet rs = sqLrequest.getValuesOfAutoGeneratedRequest(request);

		java.sql.ResultSetMetaData rsmd = rs.getMetaData();

		ArrayList<String> column = new ArrayList<>();
		ArrayList<ArrayList<String>> dataArrayList = new ArrayList<ArrayList<String>>();

		// The column count starts from 1
		for (int i = 1; i <= rsmd.getColumnCount(); i++) {

			column.add(rsmd.getColumnName(i));
			// Do stuff with name
		}

		int j = 1;
		while (rs.next()) {
			ArrayList<String> ligne = new ArrayList<>();

			for (int i = 1; i <= rsmd.getColumnCount(); i++) {

				ligne.add(rs.getString(i));
			}

			dataArrayList.add(ligne);
		}
		
		
		// transfer the arrayList to array
		String[][] data = new String[dataArrayList.size()][rsmd.getColumnCount()];
		String[] columns = new String[column.size()];
		
		for (int i = 0; i < dataArrayList.size(); i++)
			for (j = 0; j < rsmd.getColumnCount(); j++)
				data[i][j] = dataArrayList.get(i).get(j);

		for (int i = 0; i < column.size(); i++)
			columns[i]= column.get(i);

		// set the bean
		tableOfAutoGeneratedRequest.setColomnName(columns);
		tableOfAutoGeneratedRequest.setData(data);

		return tableOfAutoGeneratedRequest;
	}

	/**
	 * createSqlRequestButtonListener 
	 * @param createSqlRequestButton
	 * @param frame The Jframe 
	 * @param dataBase The database
	 */
	public void createSqlRequestButtonListener(JButton createSqlRequestButton, final JFrame frame, final DataBase dataBase) {

		// when clicking
		createSqlRequestButton.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent e) {

				dataBase.setAutoSqlRequestGenerated(getAutoGeneratedSQLRequest(dataBase.getTables()));

				// Popup the request
				JOptionPane.showMessageDialog(frame, dataBase.getAutoSqlRequestGenerated());

				try {
					
					TableOfAutoGeneratedRequest tableOfAutoGeneratedRequest;
					
					tableOfAutoGeneratedRequest = getValuesOfAutoGeneratedRequest(dataBase.getAutoSqlRequestGenerated());
					
					// visualize the request values 
					JFrame f = new JFrame("The request values");
					JTable jt = new JTable(tableOfAutoGeneratedRequest.getData(),
										   tableOfAutoGeneratedRequest.getColomnName());
								
					// TODO : add the pre-treatement 
					Instances wekaInstances = cretaeInstancesFromData(tableOfAutoGeneratedRequest.getData(), 
																  	  tableOfAutoGeneratedRequest.getColomnName());
					
					
					// validate the data set if contains missingvalues, noise, distribution, size etc.. 
					System.out.println(dataValidation(wekaInstances));

					JScrollPane sp = new JScrollPane(jt);
 			
//					//
//					JButton bt = new JButton ("Show Statis about table");
//					
					f.add(sp);
//					f.add(bt);
					f.setSize(300, 400);
					f.setVisible(true);
					
					// the GUI of the three button, Create, save and execute 
					//List<ComboItem> getChaines(); 
					
					SelectCreatExecute selectCreatExecuteJframe = new SelectCreatExecute();
					actionListenerJbuttonSave(selectCreatExecuteJframe.getjButtonSave());
					actionListenerJbuttonExecute(selectCreatExecuteJframe.getjButtonExecute(), tableOfAutoGeneratedRequest);
					selectCreatExecuteJframe.setSize(300, 400);
					selectCreatExecuteJframe.setVisible(true);

					
				} catch (SQLException e1) {
					e1.printStackTrace();
				}

			}
			
			/**
			 * Get the chaines from data base and transfer the BPMN file into String chaine. 
			 * @throws SQLException 
			 */
			public List<ComboItem> getChaines() throws SQLException {
				
				List<ComboItem> comboItems = new ArrayList<ComboItem>();
				ComboItem comboItem;
				
				ResultSet rs = sqLrequest.getChaines();
//				//readThePipelinesFromBPMN
				
				while (rs.next()) {
					
					comboItem = new ComboItem(null, rs.getString("chaine"));
				}
				
				return comboItems;
			}
			
			/**
			 * validate the data set if contains missing values, noise, distribution, size, etc.. 
			 * @param wekaInstances
			 * @return
			 */
			private Map<String, Object> dataValidation(Instances wekaInstances) {
				
				Map<String, Object> validation = new HashedMap<>();
				
				//Missing values 
				Map<String, Integer> missingInfo = new HashedMap<>();
				for (Instance instance : wekaInstances) {
					
					for (int i = 0; i <  wekaInstances.numAttributes(); i++) {
						
						int nbrOfMissingValue = 0;
						if (instance.stringValue(i).equals("?")) {
							nbrOfMissingValue++;
						}
						if (nbrOfMissingValue > 0) {
							if (missingInfo.containsKey(wekaInstances.attribute(i).name())) {
								missingInfo.put(wekaInstances.attribute(i).name(), missingInfo.get(wekaInstances.attribute(i).name()) + nbrOfMissingValue );
								
							}else  {
								missingInfo.put(wekaInstances.attribute(i).name(), nbrOfMissingValue);
							}
						}

					}
				}
				validation.put("Missing Informations", missingInfo);

				
				//Missing values 
//				Map<String, Integer> missingInfo = new HashedMap<>();
//				
//				for (int i = 0; i <  wekaInstances.numAttributes(); i++) {
//					
//					int nbrOfMissingValue = 0;
//					
//					Enumeration<Object> e = wekaInstances.attribute(i).enumerateValues();
//					
//					while (e.hasMoreElements()) {
//						
//						if ( e.nextElement().toString().equals("?")) nbrOfMissingValue++;
//					}
//					
//					if (nbrOfMissingValue > 0) missingInfo.put(wekaInstances.attribute(i).name(), nbrOfMissingValue);

					
//					for (int j = 0; j < wekaInstances.size() ; j++) {
//						
// 						if (!wekaInstances.attribute(i).value(j).isEmpty() && wekaInstances.attribute(i).value(j).equals("?")) {
//							nbrOfMissingValue++;
//						}
//					}
//					if (nbrOfMissingValue > 0) missingInfo.put(wekaInstances.attribute(i).name(), nbrOfMissingValue);

//				}
//				validation.put("Missing Informations", missingInfo);
				
				
				
				
	
				return validation;	
				
			}

			/**
			 * 
			 * @param data
			 * @param columnNames
			 * @return
			 */
			private Instances cretaeInstancesFromData(String[][] data, String[] columnNames) {
				
				// https://stackoverflow.com/questions/12118132/adding-a-new-instance-in-weka
		        ArrayList<Attribute> atts = new ArrayList<Attribute>(2);
				//ArrayList<String> classVal = new ArrayList<String>();
				//classVal.add("A");
				//classVal.add("B");
		        
		        for (int i = 0; i< columnNames.length; i++) {
		        	atts.add(new Attribute (columnNames[i]+i, (ArrayList<String>) null));
		        }
	        
				// atts.add(new Attribute("content",(ArrayList<String>)null));
				// atts.add(new Attribute("@@class@@",classVal));

		        Instances dataRaw = new Instances("TestInstances",atts,0);
 
		        for (int j=0; j<data.length;j++ ) {
		        	
			        double[] instanceValue1 = new double[dataRaw.numAttributes()];
	
			        for (int i = 0; i< columnNames.length; i++) {
			        	instanceValue1[i] = dataRaw.attribute(i).addStringValue((data[j][i]!= null) ? data[j][i] : "?");
			        }

			        dataRaw.add(new DenseInstance(1.0, instanceValue1));
		        }
		        
		        System.out.println("After adding a instance");
		        System.out.println("--------------------------");
		        System.out.println(dataRaw);
		        System.out.println("--------------------------");
 
				return dataRaw;
			}
		});
	}

	/**
	 * Listener to close connection if the user close the frame
	 * @param frame The main frame
	 */
	public void onCloseFrameListner(JFrame frame) {

		frame.addWindowListener(new WindowListener() {
					
			@Override
			public void windowClosed(WindowEvent e) {
				// TODO Auto-generated method stub
				try {
					sqLrequest.closeConnection();
				} catch (SQLException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				}
			}

			@Override
			public void windowOpened(WindowEvent e) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void windowClosing(WindowEvent e) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void windowIconified(WindowEvent e) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void windowDeiconified(WindowEvent e) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void windowActivated(WindowEvent e) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void windowDeactivated(WindowEvent e) {
				// TODO Auto-generated method stub
				
			}

		});
	}
	
	
	/**
	 * 
	 * @param getjButtonSave
	 */
	private void actionListenerJbuttonSave(JButton getjButtonSave) {

		getjButtonSave.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {

				try {

					BufferedReader br = new BufferedReader(new FileReader(StaticPaths.PATH_OF_PIPELINE));
					StringBuilder sb = new StringBuilder();
					String line;

					line = br.readLine();

					while (line != null) {
						sb.append(line);
						sb.append(System.lineSeparator());
						line = br.readLine();
					}

					String everything = sb.toString();
					sqLrequest.insertChaine(everything);

					br.close();

				} catch (IOException e1) {
					e1.printStackTrace();
				}

			}
		});

	}
    
	/**
	 * 
	 * @param getjButtonExecute
	 */
	private void actionListenerJbuttonExecute(JButton getjButtonExecute, 
											  TableOfAutoGeneratedRequest tableOfAutoGeneratedRequest) {

		
		getjButtonExecute.addActionListener(new ActionListener() {
			
			/**
			 * 
			 */
			public void actionPerformed(ActionEvent e) {
							
				try {
					
					// put the selected data into a Excel file
					createCSVFile(tableOfAutoGeneratedRequest.getData(), tableOfAutoGeneratedRequest.getColomnName());

					// read the pipeline, 
					List<String> pipeline = readThePipelinesFromBPMN();
					// put the pipeline into an Excel file
					putThePipelinesInCSV(pipeline);
					
					// execute the pipeline
					ProcessBuilder processBuilder = new ProcessBuilder(StaticPaths.PATH_PYTHON_EXEC, resolvePythonScriptPath(StaticPaths.PATH_PYTHON_PIPELINE_IMP));
					processBuilder.redirectErrorStream(false);

					Process process = processBuilder.start();

					List<String> results = readProcessOutput(process.getInputStream());

					System.out.println("------------- Result from python \n " + results);
					
					//get result from file written by python
					getResultFromFileWrittenByPython();
					
				} catch (IOException e1) {

					// TODO Auto-generated catch block
					e1.printStackTrace();
				}
			}
			
			/**
			 * get result from file written by python
			 */
			void getResultFromFileWrittenByPython() {
				
				try {
					BufferedReader br = new BufferedReader(new FileReader(StaticPaths.PATH_OF_PYTHON_RESULT));
					StringBuilder sb = new StringBuilder();
					String line;

					line = br.readLine();

					while (line != null) {
						sb.append(line);
						sb.append(System.lineSeparator());
						line = br.readLine();
					}
					
					String result  = "The getted result from python : \n " + sb.toString();
					
					JFrame printPythonResult = new PrintPythonResult(result);
					printPythonResult.setVisible(true);
					
					br.close();

				} catch (IOException e1) {
					e1.printStackTrace();
				}
				
			}
			
			/**
			 * 
			 * @param data
			 * @param colomnName
			 * @throws IOException 
			 */
			private void createCSVFile(String[][] data, String[] colomnName) throws IOException {

				// specified by filepath
				File file = new File(StaticPaths.PATH_CSV_USER_SELECTED_DATA);

				// create FileWriter object with file as parameter
				FileWriter outputfile = new FileWriter(file);

				// create CSVWriter object filewriter object as parameter
				CSVWriter writer = new CSVWriter(outputfile);

				// adding header to csv
				writer.writeNext(colomnName);

				// add data to csv
				for (int i = 0; i < data.length; i++) {
					writer.writeNext(data[i]);
				}

				// closing writer connection
				writer.close();

			}
			
			/**
			 * 
			 * @param inputStream
			 * @return
			 * @throws IOException
			 */
		    private List<String> readProcessOutput(InputStream inputStream) throws IOException {
		        try (BufferedReader output = new BufferedReader(new InputStreamReader(inputStream))) {
		            return output.lines()
		                .collect(Collectors.toList());
		        }
		    }
		    
		    /**
		     * 
		     * @param filename
		     * @return
		     */
			private String resolvePythonScriptPath(String filename) {
		        File file = new File(filename);
		        return file.getAbsolutePath();
		    }
			

			
			/**
			 * Read the pipelines
			 * @throws IOException 
			 */
			List<String> readThePipelinesFromBPMN () throws IOException {
				
				KieServices ks = KieServices.Factory.get();
				KieContainer kContainer = ks.getKieClasspathContainer();
				KieBase kbase = kContainer.getKieBase("kbase");

				RuntimeManager manager = createRuntimeManager(kbase);
				RuntimeEngine engine = manager.getRuntimeEngine(null);
				KieSession ksession = engine.getKieSession();
 		 
				WorkingMemoryInMemoryLogger inMemoryLogger = new WorkingMemoryInMemoryLogger((StatefulKnowledgeSession) engine.getKieSession());

				ksession.startProcess("com.bpmn.process1");
				
				List<String> lastNode = new ArrayList<String>();

		        for (LogEvent event : inMemoryLogger.getLogEvents()) {
		            if (event instanceof RuleFlowNodeLogEvent) {
		                String nodeName = ((RuleFlowNodeLogEvent) event).getNodeName();
		 				if (!lastNode.contains(nodeName) && lastNode!=null) {
							lastNode.add(nodeName);
							System.out.println(nodeName);
						}
		            }
		        }
		        
				manager.disposeRuntimeEngine(engine);
				manager.close();
				
				return lastNode;

			}
			
			/**
			 * 
			 * @param pipeline
			 * @throws IOException
			 */
			void putThePipelinesInCSV(List<String> pipeline) throws IOException {

				// Put the pipelines into a file

				// specified by filepath
				File file = new File(StaticPaths.PATH_CSV_PIPELINES);

				// create FileWriter object with file as parameter
				FileWriter outputfile = new FileWriter(file);

				// create CSVWriter object file writer object as parameter
				CSVWriter writer = new CSVWriter(outputfile);

				String[] pipelineArray = new String[pipeline.size()];
				int i = 0;
				for (String node : pipeline) {
					pipelineArray[i] = node;
					i++;
				}

				// adding header to csv
				writer.writeNext(pipelineArray);

				// closing writer connection
				writer.close();
			}
		});
	}
	
	/**
	 * 
	 * @param kbase
	 * @return
	 */
	private static RuntimeManager createRuntimeManager(KieBase kbase) {
		JBPMHelper.startH2Server();
		JBPMHelper.setupDataSource();
		EntityManagerFactory emf = Persistence.createEntityManagerFactory("org.jbpm.persistence.jpa");
		RuntimeEnvironmentBuilder builder = RuntimeEnvironmentBuilder.Factory.get()
			.newDefaultBuilder().entityManagerFactory(emf)
			.knowledgeBase(kbase);
		return RuntimeManagerFactory.Factory.get()
			.newSingletonRuntimeManager(builder.get(), "com.sample:example:1.0");
	}
}
