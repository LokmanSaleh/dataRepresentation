package com.automl.datarepresentation.service;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.stream.Collectors;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JScrollPane;
import javax.swing.JTable;

import org.apache.commons.collections15.map.HashedMap;

import com.automl.datarepresentation.bd.SQLrequest;
import com.automl.datarepresentation.bean.Column;
import com.automl.datarepresentation.bean.DataBase;
import com.automl.datarepresentation.bean.Table;
import com.automl.datarepresentation.bean.TableOfAutoGeneratedRequest;
import com.automl.datarepresentation.view.SelectCreatExecute;
import com.opencsv.CSVWriter;

import weka.core.Attribute;
import weka.core.DenseInstance;
import weka.core.Instance;
import weka.core.Instances;

public class DataSchemaService {
	
	SQLrequest sqLrequest;
	
	public DataSchemaService(SQLrequest sqLrequest) {
		super();
		this.sqLrequest = sqLrequest;
	}

	/**
	 * Get the schema 
	 * @param rs The result set 
	 * @return the set of tables 
	 * @throws SQLException
	 */
	public TreeMap<String, Table> getTables () throws SQLException {
		
		// get the data base schema
		ResultSet rs = sqLrequest.getRelationalDbStucture();
		
		TreeMap<String, Table> tables = new TreeMap<String, Table>();
		
		while (rs.next()) {

			if (tables.get(rs.getString("tableName")) == null) {

				Table table = new Table(rs.getString("tableName"));
				table.setNumber(tables.size());
				
				tables.put(rs.getString("tableName"), table);

				tables.get(rs.getString("tableName")).getColumns().put(rs.getString("columnName"),
						new Column(rs.getString("tablename"), rs.getString("columnName"), rs.getBoolean("isforeignkey"),
								rs.getString("parentTable"), rs.getString("parentColumn")));

			} else {
				tables.get(rs.getString("tableName")).getColumns().put(rs.getString("columnName"),
						new Column(rs.getString("tablename"), rs.getString("columnName"), rs.getBoolean("isforeignkey"),
								rs.getString("parentTable"), rs.getString("parentColumn")));
			}

		}
		
		
		return tables;

	}
	
	/**
	 * Veuillez noter que l'auto generation de requet SQL ici est exhaustive,
	 * cela, doit retourner une solution correct mais pas du facon performante.
	 * une solution performante non exhaustive, besoin de travailler sur les algorithms de graphe
	 * ce qui a besoin un peu plus du temps. Vue que notre probleme essentiel n'est pas cette point ici
	 * cette solution est semi-automatique. 
	 *
	 * @param tables
	 * @return the auto generated requested based on the user selection
	 */
	public String getAutoGeneratedSQLRequest(TreeMap<String, Table> tables) {
		
		String request = "";
		String select = "SELECT ";
		String from =" From ";
		String where=" Where ";
		
		for (Map.Entry<String, Table> table : tables.entrySet() ) {
			
			table.getValue().generateSelectFromWhere(tables);
			
			select += table.getValue().getSelect();
			from += table.getValue().getFrom();
			
			where += table.getValue().getWhere();
		}
		
		// remove the last comma
		if (select.length() > "SELECT ".length() ) 
			select = select.substring(0, select.length() -2);
		else 
			select ="";
		
		// remove the last comma
		if (from.length() > " From ".length() ) 
			from = from.substring(0, from.length() -2);
		else 
			from="";

		// remove the last AND from where
		if (where.length() > " Where ".length() ) 
			where = where.substring(0, where.length() -5);
		else 
			where = "";
		
		if (select.length() > 0)
			request = select + "\n"+ from + "\n" + where;
		else 
			request = "";
		
		return request;
	}

	/**
	 * 
	 * @param request the auto generated request
	 * @return the data selected
	 * @throws SQLException
	 */
	public TableOfAutoGeneratedRequest getValuesOfAutoGeneratedRequest(String request) throws SQLException {
		
		TableOfAutoGeneratedRequest tableOfAutoGeneratedRequest = new TableOfAutoGeneratedRequest();

		ResultSet rs = sqLrequest.getValuesOfAutoGeneratedRequest(request);

		java.sql.ResultSetMetaData rsmd = rs.getMetaData();

		ArrayList<String> column = new ArrayList<>();
		ArrayList<ArrayList<String>> dataArrayList = new ArrayList<ArrayList<String>>();

		// The column count starts from 1
		for (int i = 1; i <= rsmd.getColumnCount(); i++) {

			column.add(rsmd.getColumnName(i));
			// Do stuff with name
		}

		int j = 1;
		while (rs.next()) {
			ArrayList<String> ligne = new ArrayList<>();

			for (int i = 1; i <= rsmd.getColumnCount(); i++) {

				ligne.add(rs.getString(i));
			}

			dataArrayList.add(ligne);
		}
		
		
		// transfer the arrayList to array
		String[][] data = new String[dataArrayList.size()][rsmd.getColumnCount()];
		String[] columns = new String[column.size()];
		
		for (int i = 0; i < dataArrayList.size(); i++)
			for (j = 0; j < rsmd.getColumnCount(); j++)
				data[i][j] = dataArrayList.get(i).get(j);

		for (int i = 0; i < column.size(); i++)
			columns[i]= column.get(i);

		// set the bean
		tableOfAutoGeneratedRequest.setColomnName(columns);
		tableOfAutoGeneratedRequest.setData(data);

		return tableOfAutoGeneratedRequest;
	}

	/**
	 * createSqlRequestButtonListener 
	 * @param createSqlRequestButton
	 * @param frame The Jframe 
	 * @param dataBase The database
	 */
	public void createSqlRequestButtonListener(JButton createSqlRequestButton, final JFrame frame, final DataBase dataBase) {

		// when clicking
		createSqlRequestButton.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent e) {

				dataBase.setAutoSqlRequestGenerated(getAutoGeneratedSQLRequest(dataBase.getTables()));

				// Popup the request
				JOptionPane.showMessageDialog(frame, dataBase.getAutoSqlRequestGenerated());

				try {
					
					TableOfAutoGeneratedRequest tableOfAutoGeneratedRequest;
					
					tableOfAutoGeneratedRequest = getValuesOfAutoGeneratedRequest(dataBase.getAutoSqlRequestGenerated());
					
					// visualize the request values 
					JFrame f = new JFrame("The request values");
					JTable jt = new JTable(tableOfAutoGeneratedRequest.getData(),
										   tableOfAutoGeneratedRequest.getColomnName());
					
					
					// create CSV file for python code 
					createCSVFile(tableOfAutoGeneratedRequest.getData(), 
								  tableOfAutoGeneratedRequest.getColomnName());
					
					
//			       Process process = Runtime.getRuntime().exec("python C:\\Users\\lookm\\eclipse-workspace\\test\\moduleTest\\dataTreatment.py");
//
//			       InputStream stdout = process.getInputStream();
//			       BufferedReader reader = new BufferedReader(new InputStreamReader(stdout,StandardCharsets.UTF_8));
//			       String line;
//
//		           while((line = reader.readLine()) != null){
//		               System.out.println("stdout: "+ line);
//		           }
					
					
				    ProcessBuilder processBuilder = new ProcessBuilder("C:\\Users\\lookm\\AppData\\Local\\Programs\\Python\\Python310\\python", resolvePythonScriptPath("C:\\Users\\lookm\\eclipse-workspace\\test\\moduleTest\\dataTreatment.py"));
				    processBuilder.redirectErrorStream(false);

				    Process process = processBuilder.start();
				    List<String> results = readProcessOutput(process.getInputStream());
					
				    System.out.println("------------- Result from python \n " + results);

					
					
//				    StringWriter writer = new StringWriter();
//				    ScriptContext context = new SimpleScriptContext();
//				    context.setWriter(writer);
//				    
//				    
//				    ScriptEngineManager manager = new ScriptEngineManager();
//				    ScriptEngine engine = manager.getEngineByName("python");
//				    engine.eval(new FileReader(resolvePythonScriptPath("C:\\Users\\lookm\\eclipse-workspace\\test\\moduleTest\\dataTreatment.py")), context);
//				    
//				    System.out.println("------------- Result from python \n "  + writer.toString().trim());
//					
//					
					
					
					
					
					// TODO : add the pre-treatement 
					Instances wekaInstances = cretaeInstancesFromData(tableOfAutoGeneratedRequest.getData(), 
																  	  tableOfAutoGeneratedRequest.getColomnName());
					
					
					// validate the data set if contains missingvalues, noise, distribution, size etc.. 
					System.out.println(dataValidation(wekaInstances));

					JScrollPane sp = new JScrollPane(jt);
 			
//					//
//					JButton bt = new JButton ("Show Statis about table");
//					
					f.add(sp);
//					f.add(bt);
					f.setSize(300, 400);
					f.setVisible(true);
					
					// the GUI of the three button, Create, save and execute 
					SelectCreatExecute selectCreatExecuteJframe = new SelectCreatExecute();
					actionListenerJbuttonSave(selectCreatExecuteJframe.getjButtonSave());
					selectCreatExecuteJframe.setSize(300, 400);
					selectCreatExecuteJframe.setVisible(true);
					
				} catch (SQLException | IOException e1) {
					e1.printStackTrace();
				}

			}

		    /**
		     * 
		     * @param filename
		     * @return
		     */
			private String resolvePythonScriptPath(String filename) {
		        File file = new File(filename);
		        return file.getAbsolutePath();
		    }
		    
			/**
			 * 
			 * @param inputStream
			 * @return
			 * @throws IOException
			 */
		    private List<String> readProcessOutput(InputStream inputStream) throws IOException {
		        try (BufferedReader output = new BufferedReader(new InputStreamReader(inputStream))) {
		            return output.lines()
		                .collect(Collectors.toList());
		        }
		    }
		    
			/**
			 * 
			 * @param data
			 * @param colomnName
			 * @throws IOException 
			 */
			private void createCSVFile(String[][] data, String[] colomnName) throws IOException {
 
				// specified by filepath
				File file = new File("C:\\Users\\lookm\\git\\dataRepresentation\\createCSVFile.csv");

				// create FileWriter object with file as parameter
				FileWriter outputfile = new FileWriter(file);

				// create CSVWriter object filewriter object as parameter
				CSVWriter writer = new CSVWriter(outputfile);

				// adding header to csv
				writer.writeNext(colomnName);

				// add data to csv
				for (int i = 0; i < data.length; i++) {
					writer.writeNext(data[i]);
				}

				// closing writer connection
				writer.close();
 
			}

			/**
			 * validate the data set if contains missing values, noise, distribution, size, etc.. 
			 * @param wekaInstances
			 * @return
			 */
			private Map<String, Object> dataValidation(Instances wekaInstances) {
				
				Map<String, Object> validation = new HashedMap<>();
				
				//Missing values 
				Map<String, Integer> missingInfo = new HashedMap<>();
				for (Instance instance : wekaInstances) {
					
					for (int i = 0; i <  wekaInstances.numAttributes(); i++) {
						
						int nbrOfMissingValue = 0;
						if (instance.stringValue(i).equals("?")) {
							nbrOfMissingValue++;
						}
						if (nbrOfMissingValue > 0) {
							if (missingInfo.containsKey(wekaInstances.attribute(i).name())) {
								missingInfo.put(wekaInstances.attribute(i).name(), missingInfo.get(wekaInstances.attribute(i).name()) + nbrOfMissingValue );
								
							}else  {
								missingInfo.put(wekaInstances.attribute(i).name(), nbrOfMissingValue);
							}
						}

					}
				}
				validation.put("Missing Informations", missingInfo);

				
				//Missing values 
//				Map<String, Integer> missingInfo = new HashedMap<>();
//				
//				for (int i = 0; i <  wekaInstances.numAttributes(); i++) {
//					
//					int nbrOfMissingValue = 0;
//					
//					Enumeration<Object> e = wekaInstances.attribute(i).enumerateValues();
//					
//					while (e.hasMoreElements()) {
//						
//						if ( e.nextElement().toString().equals("?")) nbrOfMissingValue++;
//					}
//					
//					if (nbrOfMissingValue > 0) missingInfo.put(wekaInstances.attribute(i).name(), nbrOfMissingValue);

					
//					for (int j = 0; j < wekaInstances.size() ; j++) {
//						
// 						if (!wekaInstances.attribute(i).value(j).isEmpty() && wekaInstances.attribute(i).value(j).equals("?")) {
//							nbrOfMissingValue++;
//						}
//					}
//					if (nbrOfMissingValue > 0) missingInfo.put(wekaInstances.attribute(i).name(), nbrOfMissingValue);

//				}
//				validation.put("Missing Informations", missingInfo);
				
				
				
				
	
				return validation;	
				
			}

			/**
			 * 
			 * @param data
			 * @param columnNames
			 * @return
			 */
			private Instances cretaeInstancesFromData(String[][] data, String[] columnNames) {
				
				// https://stackoverflow.com/questions/12118132/adding-a-new-instance-in-weka
		        ArrayList<Attribute> atts = new ArrayList<Attribute>(2);
				//ArrayList<String> classVal = new ArrayList<String>();
				//classVal.add("A");
				//classVal.add("B");
		        
		        for (int i = 0; i< columnNames.length; i++) {
		        	atts.add(new Attribute (columnNames[i]+i, (ArrayList<String>) null));
		        }
	        
				// atts.add(new Attribute("content",(ArrayList<String>)null));
				// atts.add(new Attribute("@@class@@",classVal));

		        Instances dataRaw = new Instances("TestInstances",atts,0);
 
		        for (int j=0; j<data.length;j++ ) {
		        	
			        double[] instanceValue1 = new double[dataRaw.numAttributes()];
	
			        for (int i = 0; i< columnNames.length; i++) {
			        	instanceValue1[i] = dataRaw.attribute(i).addStringValue((data[j][i]!= null) ? data[j][i] : "?");
			        }

			        dataRaw.add(new DenseInstance(1.0, instanceValue1));
		        }
		        
		        System.out.println("After adding a instance");
		        System.out.println("--------------------------");
		        System.out.println(dataRaw);
		        System.out.println("--------------------------");
 
				return dataRaw;
			}
		});
	}

	/**
	 * Listener to close connection if the user close the frame
	 * @param frame The main frame
	 */
	public void onCloseFrameListner(JFrame frame) {

		frame.addWindowListener(new WindowListener() {
					
			@Override
			public void windowClosed(WindowEvent e) {
				// TODO Auto-generated method stub
				try {
					sqLrequest.closeConnection();
				} catch (SQLException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				}
			}

			@Override
			public void windowOpened(WindowEvent e) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void windowClosing(WindowEvent e) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void windowIconified(WindowEvent e) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void windowDeiconified(WindowEvent e) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void windowActivated(WindowEvent e) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void windowDeactivated(WindowEvent e) {
				// TODO Auto-generated method stub
				
			}

		});
	}
	
	
	/**
	 * 
	 * @param getjButtonSave
	 */
	private void actionListenerJbuttonSave(JButton getjButtonSave) {

		getjButtonSave.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {

				try {

					BufferedReader br = new BufferedReader(new FileReader(
							"C:\\Users\\lookm\\git\\BPMNTest\\testProject\\src\\main\\resources\\com\\sample\\process.bpmn"));
					StringBuilder sb = new StringBuilder();
					String line;

					line = br.readLine();

					while (line != null) {
						sb.append(line);
						sb.append(System.lineSeparator());
						line = br.readLine();
					}

					String everything = sb.toString();
					sqLrequest.insertChaine(everything);

					br.close();

				} catch (IOException e1) {
					e1.printStackTrace();
				}

			}
		});

	}
    

}
